#!/usr/bin/env python3


from argparse import ArgumentParser, Namespace
from enum import Enum
from itertools import islice
from random import choice
from sys import stdin
from typing import Dict, Iterator, List, Optional, Tuple, cast


class Flags(Enum):
    LES = 1
    GAY = 2
    BI = 3
    TRANS = 4
    ACE = 5
    PAN = 6
    ENBY = 7


class Background(Enum):
    NONE = 1
    LIGHT = 2
    DARK = 3


Colour = str
Palette = List[str]
RGB = Tuple[int, int, int]


FLAG_PALETTE: Dict[Flags, Palette] = {
    Flags.LES: ["#D62E02", "#FD9855", "#FFFFFF", "#D161A2", "#A20160"],
    Flags.GAY: ["#FF0018", "#FFA52C", "#FFFF41", "#008018", "#0000F9", "#86007D"],
    Flags.BI: ["#D60270", "#9B4F96", "#0038A8"],
    Flags.TRANS: ["#55CDFC", "#F7A8B8", "#FFFFFF", "#F7A8B8", "#55CDFC"],
    Flags.ACE: ["#000000", "#A4A4A4", "#FFFFFF", "#810081"],
    Flags.PAN: ["#FF1B8D", "#FFDA00", "#1BB3FF"],
    Flags.ENBY: ["#FFF430", "#FFFFFF", "#9C59D1", "#000000"],
}


BACKGROUND_PALETTE: Dict[Background, Optional[Colour]] = {
    Background.NONE: None,
    Background.LIGHT: "#FAFAFA",
    Background.DARK: "#606060",
}


def parse_args() -> Namespace:
    rand_flag = choice([f for f in Flags])
    namespace = Namespace(flag=rand_flag, background=Background.NONE)

    parser = ArgumentParser()
    parser.add_argument("--raw", action="store_true")

    parser.add_argument(
        "-l", "--les", "--lesbian", action="store_const", dest="flag", const=Flags.LES,
    )
    parser.add_argument(
        "-g", "--gay", action="store_const", dest="flag", const=Flags.GAY,
    )
    parser.add_argument(
        "-b", "--bi", "--bisexual", action="store_const", dest="flag", const=Flags.BI,
    )
    parser.add_argument(
        "-t",
        "--trans",
        "--transgender",
        action="store_const",
        dest="flag",
        const=Flags.TRANS,
    )
    parser.add_argument(
        "-a", "--ace", "--asexual", action="store_const", dest="flag", const=Flags.ACE,
    )
    parser.add_argument(
        "-p",
        "--pan",
        "--pansexual",
        action="store_const",
        dest="flag",
        const=Flags.PAN,
    )
    parser.add_argument(
        "-e", "--enby", action="store_const", dest="flag", const=Flags.ENBY,
    )
    parser.add_argument(
        "--light", action="store_const", dest="background", const=Background.LIGHT
    )
    parser.add_argument(
        "--dark", action="store_const", dest="background", const=Background.DARK
    )

    return parser.parse_args(namespace=namespace)


def right_pad(lines: List[str]) -> Iterator[str]:
    max_len = max(map(len, lines))
    for line in lines:
        dif = max_len - len(line)
        yield line + " " * dif


def parse_colour(colour: Colour) -> RGB:
    hexc = colour[1:]
    it = iter(hexc)
    parsed = tuple(
        int(f"{h1}{h2}", 16) for h1, h2 in iter(lambda: tuple(islice(it, 2)), ())
    )
    return cast(RGB, parsed)


def lerp(c1: RGB, c2: RGB, mix: int) -> RGB:
    lhs = map(lambda c: c * mix, c1)
    rhs = map(lambda c: c * (1 - mix), c2)
    new = map(lambda c: int(round(sum(c))), zip(lhs, rhs))
    return tuple(new)


def nearest(rgb: RGB) -> int:
    return


def colourize(
    palette: Palette, bg: Optional[Colour], lines: Iterator[str]
) -> Iterator[str]:
    for line in lines:
        for char in line:
            yield char
        yield "\n"


def main() -> None:
    args = parse_args()
    lines = stdin.read().splitlines()
    padded = right_pad(lines)
    palette = FLAG_PALETTE[args.flag]
    bg = BACKGROUND_PALETTE[args.background]
    new_lines = colourize(palette, bg, padded)
    pretty = "".join(new_lines)
    print(pretty, end="")


try:
    main()
except KeyboardInterrupt:
    pass
