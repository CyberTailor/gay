#!/usr/bin/env python3


from argparse import ArgumentParser, Namespace
from atexit import register
from enum import Enum
from itertools import chain, count, cycle, islice, repeat
from math import pi, sin
from os import environ
from random import choice, randint
from shutil import get_terminal_size
from signal import SIG_DFL, SIGPIPE, signal
from sys import stdin
from typing import Callable, Dict, Iterator, List, Optional, Tuple, cast
from unicodedata import east_asian_width


class ColourSpace(Enum):
    EIGHT = "8"
    TRUE = "24"


class Gradient(Enum):
    D1 = "1d"
    D2 = "2d"


class Flags(Enum):
    LES = 1
    GAY = 2
    BI = 3
    TRANS = 4
    ACE = 5
    PAN = 6
    NB = 7
    GQ = 8


HexColour = str
RGB = Tuple[int, int, int]
RawPalette = List[HexColour]
Palette = List[RGB]


COLS, ROWS = get_terminal_size((80, 80))

UNICODE_WIDTH_LOOKUP = {
    "W": 2,  # CJK
    "N": 0,  # Non printable
}

ASPECT_RATIO = (3, 5)
FLAG_SPECS: Dict[Flags, RawPalette] = {
    Flags.LES: ["#D62E02", "#FD9855", "#FFFFFF", "#D161A2", "#A20160"],
    Flags.GAY: ["#FF0018", "#FFA52C", "#FFFF41", "#008018", "#0000F9", "#86007D"],
    Flags.BI: ["#D60270", "#D60270", "#9B4F96", "#0038A8", "#0038A8"],
    Flags.TRANS: ["#55CDFC", "#F7A8B8", "#FFFFFF", "#F7A8B8", "#55CDFC"],
    Flags.ACE: ["#000000", "#A4A4A4", "#FFFFFF", "#810081"],
    Flags.PAN: ["#FF1B8D", "#FFDA00", "#1BB3FF"],
    Flags.NB: ["#FFF430", "#FFFFFF", "#9C59D1", "#000000"],
    Flags.GQ: ["#B77FDD", "#FFFFFF", "#48821E"],
}


def parse_args() -> Namespace:
    rand_flag = choice(tuple(f for f in Flags))
    rand_interpolation = choice(tuple(i.value for i in Gradient))
    colour_space = (
        ColourSpace.TRUE
        if environ.get("COLORTERM") in {"truecolor", "24bit"}
        else ColourSpace.EIGHT
    )
    namespace = Namespace(flag=rand_flag)
    parser = ArgumentParser()

    mode_group = parser.add_argument_group()
    mode_group.add_argument("-f", "--flag", dest="flag_only", action="store_true")

    flag_group = parser.add_argument_group()
    flag_group.add_argument(
        "-l", "--les", "--lesbian", action="store_const", dest="flag", const=Flags.LES,
    )
    flag_group.add_argument(
        "-g", "--gay", action="store_const", dest="flag", const=Flags.GAY,
    )
    flag_group.add_argument(
        "-b", "--bi", "--bisexual", action="store_const", dest="flag", const=Flags.BI,
    )
    flag_group.add_argument(
        "-t",
        "--trans",
        "--transgender",
        action="store_const",
        dest="flag",
        const=Flags.TRANS,
    )
    flag_group.add_argument(
        "-a", "--ace", "--asexual", action="store_const", dest="flag", const=Flags.ACE,
    )
    flag_group.add_argument(
        "-p",
        "--pan",
        "--pansexual",
        action="store_const",
        dest="flag",
        const=Flags.PAN,
    )
    flag_group.add_argument(
        "-n", "--nb", "--non-binary", action="store_const", dest="flag", const=Flags.NB,
    )
    flag_group.add_argument(
        "--gq", "--gender-queer", action="store_const", dest="flag", const=Flags.GQ,
    )

    opt_group = parser.add_argument_group()
    opt_group.add_argument(
        "-c",
        "--colour",
        choices=tuple(c.value for c in ColourSpace),
        default=colour_space.value,
    )
    opt_group.add_argument(
        "-i",
        "--interpolation",
        choices=tuple(i.value for i in Gradient),
        default=rand_interpolation,
    )
    opt_group.add_argument("--period", type=lambda i: max(abs(int(i)), 1))
    opt_group.add_argument("--tabs", type=lambda i: max(abs(int(i)), 1), default=4)

    return parser.parse_args(namespace=namespace)


def on_exit() -> None:
    print("\033[0m", end="", flush=True)


def stdin_stream() -> Iterator[str]:
    while True:
        size = COLS * 2
        line = stdin.read(size)
        if line:
            yield from line
        else:
            break


def normalize_width(tab_width: int, stream: Iterator[str]) -> Iterator[str]:
    for char in stream:
        if char == "\t":
            yield from repeat(" ", tab_width)
        else:
            yield char


def unicode_width(stream: Iterator[str]) -> Iterator[Tuple[int, str]]:
    def char_width(char: str) -> int:
        try:
            code = east_asian_width(char)
            return UNICODE_WIDTH_LOOKUP.get(code, 1)
        except Exception:
            return 1

    for char in stream:
        yield char_width(char), char


def parse_raw_palette(raw: RawPalette) -> Palette:
    def parse_colour(colour: HexColour) -> RGB:
        hexc = colour[1:]
        it = iter(hexc)
        parsed = tuple(
            int(f"{h1}{h2}", 16) for h1, h2 in iter(lambda: tuple(islice(it, 2)), ())
        )
        return cast(RGB, parsed)

    return [parse_colour(p) for p in raw]


def decor_8(rgb: RGB) -> Iterator[str]:
    r, g, b = map(lambda c: int(round(c / 255 * 5)), rgb)
    yield ";"
    yield str(16 + 36 * r + 6 * g + b)


def decor_24(rgb: RGB) -> Iterator[str]:
    yield from chain(*zip(repeat(";"), map(str, rgb)))


def decor_for(space: ColourSpace) -> Tuple[str, str, Callable[[RGB], Iterator[str]]]:
    if space == ColourSpace.EIGHT:
        return "\033[38;5", "\033[48;5", decor_8
    elif space == ColourSpace.TRUE:
        return "\033[38;2", "\033[48;2", decor_24
    else:
        raise ValueError()


def paint_flag(colour_space: ColourSpace, palette: Palette) -> Iterator[str]:
    r, c = ASPECT_RATIO
    _, bg_esc, decor = decor_for(colour_space)
    height = len(palette)
    ratio = r / c * 0.5
    multiplier = max(int(min((ROWS - 4) / height, COLS / height * ratio)), 1)
    line = " " * COLS
    for colour in palette:
        for _ in range(multiplier):
            yield bg_esc
            yield from decor(colour)
            yield "m"
            yield line
            yield "\033[0m"
            yield "\n"


def lerp(c1: RGB, c2: RGB, mix: float) -> RGB:
    lhs = map(lambda c: c * mix, c1)
    rhs = map(lambda c: c * (1 - mix), c2)
    new = map(lambda c: int(round(sum(c))), zip(lhs, rhs))
    return cast(RGB, tuple(new))


def enumerate_lines(stream: Iterator[str]) -> Iterator[Tuple[bool, int, str]]:

    l_stream = unicode_width(stream)
    prev: Optional[Tuple[int, str]] = next(l_stream, None)
    x = 0 if prev is None else 1

    def drain(ret: bool) -> Iterator[Tuple[bool, int, str]]:
        nonlocal prev
        if prev is not None:
            yield (ret, *prev)
            prev = None

    for width, char in l_stream:
        new = x + width
        if new > COLS:
            yield from drain(True)
            prev = (width, char)
            x = width
        elif new == COLS or char == "\n":
            yield from drain(False)
            yield True, width, char
            x = 0
        else:
            yield from drain(False)
            prev = (width, char)
            x = new

    yield from drain(False)


def interpolation_short(palette: Palette, rep: int) -> Iterator[Iterator[RGB]]:
    gen = cycle(palette)
    period = pi * pi / 2

    def wave(t: float) -> float:
        x = t / rep * period
        return sin(x / pi + pi / 2)

    def once() -> Iterator[RGB]:
        prev = next(gen)
        while True:
            curr = next(gen)
            for t in range(rep + 1):
                mix = wave(t)
                yield lerp(prev, curr, mix)
            prev = curr

    it = once()
    while True:
        yield it


def interpolation_long(palette: Palette, rep: int) -> Iterator[Iterator[RGB]]:
    gen = cycle(palette)

    period = pi * pi / 2

    def wave(t: float) -> float:
        x = t / rep * period
        return sin(x / pi + pi / 2)

    for y in count():

        def line() -> Iterator[RGB]:
            x = 0
            while True:
                yield (randint(0, 255), randint(0, 255), randint(0, 255))
                x += 1

        yield line()


def interpolation_for(
    mode: Gradient, palette: Palette, rep: Optional[int]
) -> Iterator[Iterator[RGB]]:
    if mode == Gradient.D1:
        period = rep or randint(5, 15)
        return interpolation_short(palette, period)
    if mode == Gradient.D2:
        period = rep or randint(3, 5)
        return interpolation_long(palette, period)
    else:
        raise ValueError()


def colourize(
    colour_space: ColourSpace, rgb_gen: Iterator[Iterator[RGB]], stream: Iterator[str],
) -> Iterator[str]:
    fg_esc, _, decor = decor_for(colour_space)
    colour_gen = next(rgb_gen)
    for new_line, width, char in enumerate_lines(stream):
        if width:
            colour = next(colour_gen)
            yield fg_esc
            yield from decor(colour)
            yield "m"
        yield char
        if new_line:
            yield "\033[0m"
            colour_gen = next(rgb_gen)


def main() -> None:
    signal(SIGPIPE, SIG_DFL)
    args = parse_args()
    register(on_exit)
    colour_space = ColourSpace(args.colour)
    palette = parse_raw_palette(FLAG_SPECS[args.flag])

    if args.flag_only:
        flag_stripes = paint_flag(colour_space=colour_space, palette=palette)
        print(*flag_stripes, sep="", end="")
    else:
        stream = stdin_stream()
        normalized_stream = normalize_width(args.tabs, stream)
        interpolation = Gradient(args.interpolation)

        rgb_gen = interpolation_for(
            mode=interpolation, palette=palette, rep=args.period
        )
        gen = colourize(
            colour_space=colour_space, rgb_gen=rgb_gen, stream=normalized_stream,
        )
        for chunk in iter(lambda: tuple(islice(gen, COLS)), ()):
            print(*chunk, sep="", end="")


try:
    main()
except KeyboardInterrupt:
    exit(130)
