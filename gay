#!/usr/bin/env python3


from argparse import ArgumentParser, Namespace
from enum import Enum
from itertools import islice
from random import choice, randint
from sys import stdin
from typing import Callable, Dict, Iterator, List, Optional, Tuple, cast


class ColourSpace(Enum):
    EIGHT = "8"
    TRUE = "24"


class Flags(Enum):
    LES = 1
    GAY = 2
    BI = 3
    TRANS = 4
    ACE = 5
    PAN = 6
    ENBY = 7


class Background(Enum):
    NONE = 1
    LIGHT = 2
    DARK = 3


HexColour = str
RGB = Tuple[int, int, int]
RawPalette = List[HexColour]
Palette = List[RGB]


FLAG_PALETTE: Dict[Flags, RawPalette] = {
    Flags.LES: ["#D62E02", "#FD9855", "#FFFFFF", "#D161A2", "#A20160"],
    Flags.GAY: ["#FF0018", "#FFA52C", "#FFFF41", "#008018", "#0000F9", "#86007D"],
    Flags.BI: ["#D60270", "#9B4F96", "#0038A8"],
    Flags.TRANS: ["#55CDFC", "#F7A8B8", "#FFFFFF", "#F7A8B8", "#55CDFC"],
    Flags.ACE: ["#000000", "#A4A4A4", "#FFFFFF", "#810081"],
    Flags.PAN: ["#FF1B8D", "#FFDA00", "#1BB3FF"],
    Flags.ENBY: ["#FFF430", "#FFFFFF", "#9C59D1", "#000000"],
}


BACKGROUND_PALETTE: Dict[Background, Optional[HexColour]] = {
    Background.NONE: None,
    Background.LIGHT: "#FAFAFA",
    Background.DARK: "#202020",
}


def parse_args() -> Namespace:
    rand_flag = choice([f for f in Flags])
    namespace = Namespace(flag=rand_flag, background=Background.NONE)

    parser = ArgumentParser()
    parser.add_argument("-f", "--flag", dest="flag_only", action="store_true")

    parser.add_argument(
        "--colour", choices=[c.value for c in ColourSpace], default="24",
    )

    parser.add_argument(
        "-l", "--les", "--lesbian", action="store_const", dest="flag", const=Flags.LES,
    )
    parser.add_argument(
        "-g", "--gay", action="store_const", dest="flag", const=Flags.GAY,
    )
    parser.add_argument(
        "-b", "--bi", "--bisexual", action="store_const", dest="flag", const=Flags.BI,
    )
    parser.add_argument(
        "-t",
        "--trans",
        "--transgender",
        action="store_const",
        dest="flag",
        const=Flags.TRANS,
    )
    parser.add_argument(
        "-a", "--ace", "--asexual", action="store_const", dest="flag", const=Flags.ACE,
    )
    parser.add_argument(
        "-p",
        "--pan",
        "--pansexual",
        action="store_const",
        dest="flag",
        const=Flags.PAN,
    )
    parser.add_argument(
        "-e", "--enby", action="store_const", dest="flag", const=Flags.ENBY,
    )
    parser.add_argument("-s", "--straight", action="store_true")

    parser.add_argument(
        "--light", action="store_const", dest="background", const=Background.LIGHT
    )
    parser.add_argument(
        "--dark", action="store_const", dest="background", const=Background.DARK
    )

    return parser.parse_args(namespace=namespace)


def right_pad(max_len: int, lines: List[str]) -> Iterator[str]:
    for line in lines:
        dif = max_len - len(line)
        yield line + " " * dif


def parse_colour(colour: HexColour) -> RGB:
    hexc = colour[1:]
    it = iter(hexc)
    parsed = tuple(
        int(f"{h1}{h2}", 16) for h1, h2 in iter(lambda: tuple(islice(it, 2)), ())
    )
    return cast(RGB, parsed)


def lerp(c1: RGB, c2: RGB, mix: int) -> RGB:
    lhs = map(lambda c: c * mix, c1)
    rhs = map(lambda c: c * (1 - mix), c2)
    new = map(sum, zip(lhs, rhs))
    return cast(RGB, tuple(new))


def decor_8(rgb: RGB) -> str:
    r, g, b = map(lambda c: c / 255 * 5, rgb)
    return str(16 + 36 * r + 6 * g + b)


def decor_24(rgb: RGB) -> str:
    return ";".join(map(str, rgb))


def decor_for(space: ColourSpace) -> Tuple[str, str, Callable[[RGB], str]]:
    if space == ColourSpace.EIGHT:
        return "\033[38;5;", "\033[48;5;", decor_8
    elif space == ColourSpace.TRUE:
        return "\033[38;2;", "\033[48;2;", decor_24
    else:
        raise ValueError()


def colourize(
    colour_space: ColourSpace,
    palette: Palette,
    bg: Optional[RGB],
    rows: int,
    cols: int,
    lines: Iterator[str],
) -> Iterator[str]:
    fg_esc, bg_esc, decor = decor_for(colour_space)
    bg_colour = decor(bg) if bg else ""
    for line in lines:
        if bg:
            yield bg_esc
            yield bg_colour
            yield "m"
        for char in line:
            colour = (randint(0, 255), randint(0, 255), randint(0, 255))
            yield fg_esc
            yield decor(colour)
            yield "m"
            yield char
        yield "\033[0m"
        yield "\n"


def main() -> None:
    args = parse_args()
    data = stdin.read()

    if args.straight:
        print(data, end="")
        return

    lines = data.splitlines()
    rows, cols = len(lines), max(map(len, lines))
    padded = right_pad(cols, lines)

    colour_space = ColourSpace(args.colour)
    palette = [*map(parse_colour, FLAG_PALETTE[args.flag])]
    bg = (
        None
        if args.background == Background.NONE
        else parse_colour(BACKGROUND_PALETTE[args.background])
    )

    new_lines = colourize(
        colour_space=colour_space,
        palette=palette,
        bg=bg,
        rows=rows,
        cols=cols,
        lines=padded,
    )
    pretty = "".join(new_lines)
    print(pretty, end="")


try:
    main()
except KeyboardInterrupt:
    pass
